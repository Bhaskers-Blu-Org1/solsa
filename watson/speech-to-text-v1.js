// Autogenerated. DO NOT MODIFY

const solsa = require('../solsa')
const _SpeechToTextV1 = require('watson-developer-cloud/speech-to-text/v1-generated')

class SpeechToTextV1 extends solsa.Service {
  constructor (name) {
    super(name, true)

    this.url = this.addSecret(`binding-${name}`, 'url')
    this.apikey = this.addSecret(`binding-${name}`, 'apikey')
  }
  async listModels (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listModels(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async recognize (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.recognize(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async registerCallback (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.registerCallback(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async unregisterCallback (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.unregisterCallback(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async checkJobs (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.checkJobs(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async createJob (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.createJob(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async checkJob (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.checkJob(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteJob (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteJob(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async listLanguageModels (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listLanguageModels(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async createLanguageModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.createLanguageModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getLanguageModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getLanguageModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteLanguageModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteLanguageModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async trainLanguageModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.trainLanguageModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async resetLanguageModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.resetLanguageModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async upgradeLanguageModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.upgradeLanguageModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async listCorpora (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listCorpora(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getCorpus (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getCorpus(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async addCorpus (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.addCorpus(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteCorpus (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteCorpus(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async listWords (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listWords(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async addWords (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.addWords(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getWord (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getWord(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async addWord (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.addWord(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteWord (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteWord(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async listGrammars (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listGrammars(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getGrammar (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getGrammar(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async addGrammar (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.addGrammar(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteGrammar (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteGrammar(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async listAcousticModels (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listAcousticModels(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async createAcousticModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.createAcousticModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getAcousticModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getAcousticModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteAcousticModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteAcousticModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async trainAcousticModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.trainAcousticModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async resetAcousticModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.resetAcousticModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async upgradeAcousticModel (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.upgradeAcousticModel(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async listAudio (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.listAudio(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async getAudio (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.getAudio(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async addAudio (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.addAudio(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteAudio (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteAudio(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }
  async deleteUserData (params) {
    return new Promise((resolve, reject) => {
      if (this.delegate === undefined) {
        this.delegate = new _SpeechToTextV1({ iam_apikey: this.apikey, url: this.url })
      }
      this.delegate.deleteUserData(params, (err, res) => {
        if (err) {
          return reject(err)
        }
        return resolve(res)
      })
    })
  }

  _yaml (archive) {
    const svc = {
      apiVersion: 'ibmcloud.seed.ibm.com/v1beta1',
      kind: 'Service',
      metadata: {
        name: this.name
      },
      spec: {
        service: 'speech-to-text',
        plan: 'lite',
        servicetype: 'IAM'
      }
    }
    archive.addResource(svc, this.name + '-svc.yaml')
    const binding = {
      apiVersion: 'ibmcloud.seed.ibm.com/v1beta1',
      kind: 'Binding',
      metadata: {
        name: `binding-${this.name}`
      },
      spec: {
        bindingFrom: {
          name: this.name
        },
        servicetype: 'IAM'
      }
    }
    archive.addResource(binding, this.name + '-binding.yaml')
  }
}

module.exports = SpeechToTextV1
