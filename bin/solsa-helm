#!/usr/bin/env node

let yaml = require('js-yaml')
const minimist = require('minimist')
const fs = require('fs')
const archiver = require('archiver')

function setupArchiver(chartName) {
  var output = fs.createWriteStream('chartName' + '.tar.gz');
  var archive = archiver('tar', {
    gzip: true,
    zlib: { level: 9 }
  });

  // listen for all archive data to be written
  // 'close' event is fired only when a file descriptor is involved
  output.on('close', function () {
    console.log(archive.pointer() + ' total bytes');
    console.log('archiver has been finalized and the output file descriptor has closed.');
  });

  // good practice to catch warnings (ie stat failures and other non-blocking errors)
  archive.on('warning', function (err) {
    if (err.code === 'ENOENT') {
      // log warning
    } else {
      // throw error
      throw err;
    }
  });

  // good practice to catch this error explicitly
  archive.on('error', function (err) {
    throw err;
  });

  // pipe archive data to the file
  archive.pipe(output);

  return archive
}

function generateChartSkeleton(archive, app) {
  const c = {
    apiVersion: 'v1',
    name: app.name,
  }
  archive.append(yaml.safeDump(c, { noArrayIndent: true }), { name: app.name+'/Chart.yaml' })

  return app.name+'/templates/'
}

const argv = minimist(process.argv.slice(2), {
  default: { target: 'kubernetes', output: 'my-chart' },
  alias: { target: 't', output: 'o' },
  string: ['target', 'output']
});

const archive = setupArchiver(argv.output);
const theApp = require(require('path').resolve(argv._[0]));
const templateDir = generateChartSkeleton(archive, theApp);
theApp._helm(archive, argv.target, templateDir);

archive.finalize();
